/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
	bool dfs(int u, int dst, int edgesCount, int k, vector<vector<pair<int,int>>>&adj, vector<bool>&visited, int mid) {
		if (u == dst && edgesCount <= k) {
			return true;
		}

		visited[u] = true;
		for(int i=0; i<adj[u].size(); i++) {
			int nu = adj[u][i].first;
			int wt = adj[u][i].second;
			if (!visited[nu] && wt <= mid && edgesCount+1 <= k && dfs(nu, dst, edgesCount+1, k, adj, visited, mid)) {
				return true;
			}
		}
		visited[u] = false;
		return false;
	}

	bool check_1(vector<vector<pair<int,int>>>&adj, int mid, int n, int k) {
		vector<bool>visited(n, false);
		int edgesCount = 0;
		return dfs(0, n-1, edgesCount, k, adj, visited, mid);
	}

	bool check_2(vector<vector<pair<int,int>>>& adj, int mid, int n, int k) {
		queue<pair<int,int>> q; // {node, edges_used}
		vector<vector<bool>> visited(n, vector<bool>(k + 1, false));

		q.push({0, 0});
		visited[0][0] = true;

		while (!q.empty()) {
			auto [u, edgesUsed] = q.front();
			q.pop();

			if (u == n - 1) {
			    return true;
			}
			
			if (edgesUsed == k) {
			    continue;
			}

			for (auto &[v, wt] : adj[u]) {
				if (wt <= mid && !visited[v][edgesUsed + 1]) {
					visited[v][edgesUsed + 1] = true;
					q.push({v, edgesUsed + 1});
				}
			}
		}
		return false;
	}

public:
	int solve(vector<vector<int>>&edges, int n, int k) {
		vector<vector<pair<int,int>>>adj(n);
		int l = INT_MAX;
		int r = INT_MIN;
		
		for(int i=0; i<edges.size(); i++) {
			int u = edges[i][0];
			int v = edges[i][1];
			int wt = edges[i][2];

			adj[u].push_back({v,wt});
			adj[v].push_back({u,wt});
			
			l = min(l, wt);
			r = max(r, wt);
		}

		int ans;

		while(l<=r) {
			int mid = l + (r-l)/2;
			if (check_1(adj, mid, n, k)) { // check_2 has better time complexity
				ans = mid;
				r = mid-1;
			} else {
				l = mid+1;
			}
		}
		return ans;
	}
};

int main() {
	vector<vector<int>>edges;

//   edges.push_back({0,1,4});
//   edges.push_back({0,2,2});
//   edges.push_back({1,3,5});
//   edges.push_back({1,2,6});
//   int N = 4;
//   int K = 3;

	//   edges.push_back({0,1,2});
	//   edges.push_back({0,4,6});
	//   edges.push_back({0,3,1});
	//   edges.push_back({1,4,7});
	//   edges.push_back({1,5,8});
	//   edges.push_back({1,2,4});
	//   edges.push_back({2,5,9});
	//   edges.push_back({2,3,5});
	//   edges.push_back({3,5,2});
	//   int N = 6;
	//   int K = 3;

	Solution* solution = new Solution();
	cout<<solution->solve(edges, N, K);
}
