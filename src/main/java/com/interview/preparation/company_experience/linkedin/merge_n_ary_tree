#include<bits/stdc++.h>
using namespace std;

// Merge n-ary tree
class TreeNode {
  public:
    int val;
    vector<TreeNode*>children;

    TreeNode(int val) {
        this->val = val;
    }
};

class Solution {
  public:
    TreeNode* solve(TreeNode* root1, TreeNode* root2) {
        if (root1 == NULL && root2 == NULL) {
            return NULL;
        }
        if (root1 == NULL && root2 != NULL) {
            return root2;
        }
        if (root1 != NULL && root2 == NULL) {
            return root1;
        }

        TreeNode* root = new TreeNode(root1->val + root2->val);
        vector<TreeNode*>children;

        int i = 0, j = 0;
        while(i < root1->children.size() && j < root2->children.size()) {
            TreeNode* child1 = root1->children[i];
            TreeNode* child2 = root2->children[j];

            TreeNode* child = solve(child1, child2);
            children.push_back(child);

            i++;
            j++;
        }

        while(i < root1->children.size()) {
            TreeNode* child1 = root1->children[i];
            TreeNode* child = new TreeNode(child1->val);
            // TreeNode* child = solve(child1, NULL);
            children.push_back(child);
            i++;
        }

        while(j < root2->children.size()) {
            TreeNode* child2 = root2->children[j];
            TreeNode* child = new TreeNode(child2->val);
            children.push_back(child);
            j++;
        }

        root->children = children;
        return root;
    }

    void levelOrderTraversal(TreeNode* root) {
        if (root == NULL) {
            return ;
        }
        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty()) {
            int size = q.size();
            while(size--) {
                TreeNode* node = q.front();
                q.pop();

                cout<<node->val<<" ";

                for(int i=0;i<node->children.size();i++) {
                    q.push(node->children[i]);
                }
            }
            cout<<endl;
        }
    }
};

int main() {
    TreeNode* root1 = new TreeNode(1);
    root1->children.push_back(new TreeNode(2));
    root1->children.push_back(new TreeNode(3));
    root1->children.push_back(new TreeNode(4));

    TreeNode* root2 = new TreeNode(1);
    root2->children.push_back(new TreeNode(2));
    root2->children.push_back(new TreeNode(3));

    Solution* solution = new Solution();
    TreeNode* root = solution->solve(root1, root2);

    solution->levelOrderTraversal(root);
}